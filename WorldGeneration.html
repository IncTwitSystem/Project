<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlas World Generator</title>

    <link rel="icon" type="image/png" href="Icon.png">
    
    <style>
        :root {
            --bg: #f3e8c8;
            --panel: #fff9e6;
            --border: #b89b5e;
            --text: #2b2416;
            --accent: #6b4b16;
            --hover: #eeddb6;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: "Courier New", monospace;
            background: var(--bg);
            color: var(--text);
            padding: 20px;
            min-height: 100vh;
        }
        
        header {
            padding: 40px 20px 25px;
            text-align: center;
            background: var(--panel);
            border-bottom: 4px solid var(--border);
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.8rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            border: 3px double var(--border);
            display: inline-block;
            padding: 10px 25px;
            background: #fffdf4;
            margin: 0 0 10px 0;
        }

        nav {
            margin-top: 18px;
        }

        nav a {
            display: inline-block;
            margin: 6px;
            padding: 10px 18px;
            background: #fffdf4;
            color: var(--accent);
            text-decoration: none;
            border: 2px solid var(--border);
            font-weight: bold;
            font-size: 0.9rem;
            letter-spacing: 1px;
            transition: 0.2s;
        }

        nav a:hover { background: var(--hover); }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1100px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        .controls-panel {
            background: var(--panel);
            padding: 25px;
            border: 3px solid var(--border);
            height: fit-content;
        }
        
        .section-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 18px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-item {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            background: var(--border);
            border: 1px solid var(--accent);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent);
            cursor: pointer;
            border: 2px solid var(--text);
        }
        
        .value-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.85rem;
            color: var(--accent);
        }
        
        select, button, input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border);
            font-family: "Courier New", monospace;
            font-size: 0.95rem;
            background: #fffdf4;
            color: var(--text);
            margin-top: 5px;
        }
        
        button {
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        button:hover {
            background: var(--hover);
            transform: translateY(-2px);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 15px;
        }
        
        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 15px;
        }
        
        .export-btn {
            background: var(--accent);
            color: var(--panel);
            border-color: var(--text);
        }
        
        .export-btn:hover {
            background: var(--text);
        }
        
        .terrain-toggles {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .terrain-toggle {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            background: #fffdf4;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .terrain-toggle:hover {
            background: var(--hover);
        }
        
        .terrain-toggle.active {
            background: var(--accent);
            border-color: var(--text);
            color: var(--panel);
        }
        
        .terrain-icon {
            width: 24px;
            height: 24px;
            margin-bottom: 5px;
            border: 1px solid var(--text);
        }
        
        .terrain-label {
            font-size: 0.75rem;
            font-weight: bold;
            text-align: center;
            letter-spacing: 0.5px;
        }
        
        .world-display {
            background: var(--panel);
            border: 3px solid var(--border);
            padding: 25px;
            display: flex;
            flex-direction: column;
        }
        
        .world-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }
        
        .world-header h2 {
            font-size: 1.3rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #coordinates {
            font-size: 0.85rem;
            color: var(--accent);
        }
        
        .world-canvas-container {
            width: 100%;
            height: 700px;
            overflow: auto;
            border: 2px solid var(--border);
            background: #ebe3c9;
            position: relative;
        }
        
        #worldCanvas {
            display: block;
            cursor: crosshair;
        }
        
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .stats-panel {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .stats-panel {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .stat-card {
            background: var(--panel);
            padding: 20px;
            border: 3px solid var(--border);
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent);
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            padding: 25px;
            background: var(--panel);
            border: 3px solid var(--border);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: #fffdf4;
            border: 1px solid var(--border);
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid var(--text);
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(243, 232, 200, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .spinner {
            width: 80px;
            height: 80px;
            border: 8px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 25px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 1.6rem;
            font-weight: bold;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .loading-details {
            margin-top: 15px;
            font-size: 1rem;
            color: var(--accent);
        }
        
        .notification {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--accent);
            color: var(--panel);
            padding: 15px 25px;
            border: 3px solid var(--text);
            z-index: 1001;
            transform: translateY(100px);
            transition: transform 0.3s ease;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .notification.show {
            transform: translateY(0);
        }
        
        footer {
            margin-top: 30px;
            text-align: center;
            font-size: 0.85rem;
            color: var(--accent);
            padding: 20px;
            border-top: 2px solid var(--border);
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Atlas World Generator</h1>
            <nav>
                <a href="experiments.html">Go Back</a>
            </nav>
        </header>
        
        <div class="dashboard">
            <div class="controls-panel">
                <h2 class="section-title">Configuration</h2>
                
                <div class="control-group">
                    <div class="control-item">
                        <label for="worldSize">World Size: <span id="sizeValue">256 × 256</span></label>
                        <input type="range" id="worldSize" min="64" max="512" value="256" step="1">
                        <div class="value-display">
                            <span>64</span>
                            <span>512</span>
                        </div>
                    </div>
                    
                    <div class="control-item">
                        <label for="landRatio">Land Ratio: <span id="ratioValue">45%</span></label>
                        <input type="range" id="landRatio" min="10" max="90" value="45" step="1">
                        <div class="value-display">
                            <span>10%</span>
                            <span>90%</span>
                        </div>
                    </div>
                    
                    <div class="control-item">
                        <label for="complexity">Complexity: <span id="complexityValue">6</span></label>
                        <input type="range" id="complexity" min="1" max="10" value="6" step="0.1">
                        <div class="value-display">
                            <span>Simple</span>
                            <span>Complex</span>
                        </div>
                    </div>
                </div>
                
                <h2 class="section-title">World Type</h2>
                
                <div class="control-group">
                    <div class="control-item">
                        <select id="generationType">
                            <option value="continents">Earth-like Continents</option>
                            <option value="perlin">Perlin Noise</option>
                            <option value="archipelago">Archipelago</option>
                            <option value="mountainous">Mountainous</option>
                        </select>
                    </div>
                </div>
                
                <h2 class="section-title">Terrain Types</h2>
                
                <div class="terrain-toggles">
                    <div class="terrain-toggle active" data-terrain="forests">
                        <div class="terrain-icon" style="background: #2E7D32;"></div>
                        <div class="terrain-label">Forests</div>
                    </div>
                    <div class="terrain-toggle active" data-terrain="mountains">
                        <div class="terrain-icon" style="background: #757575;"></div>
                        <div class="terrain-label">Mountains</div>
                    </div>
                    <div class="terrain-toggle active" data-terrain="beaches">
                        <div class="terrain-icon" style="background: #FFD54F;"></div>
                        <div class="terrain-label">Beaches</div>
                    </div>
                </div>

                <h2 class="section-title" style="margin-top:18px;">Editor</h2>
                <div class="control-group">
                    <div class="control-item">
                        <label>Palette</label>
                        <div id="palette" style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;">
                            <button class="palette-btn" data-index="0" style="background:#0d47a1;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="1" style="background:#1565c0;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="2" style="background:#1e88e5;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="3" style="background:#ffd54f;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="4" style="background:#7cb342;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="5" style="background:#2e7d32;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="6" style="background:#757575;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="7" style="background:#e0c068;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="8" style="background:#1b5e20;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="9" style="background:#cfd8dc;height:36px;border:2px solid var(--border);"></button>
                            <button class="palette-btn" data-index="10" style="background:#9ccc65;height:36px;border:2px solid var(--border);"></button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label for="brushSize">Brush Size: <span id="brushValue">1</span></label>
                        <input type="range" id="brushSize" min="1" max="12" value="1">
                    </div>
                    <div class="control-item">
                        <label>Mode</label>
                        <div style="display:flex;gap:8px;">
                            <button id="paintModeBtn">Paint</button>
                            <button id="eraseModeBtn">Erase</button>
                            <button id="eyedropperBtn">Eyedropper</button>
                        </div>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="generateBtn">Generate</button>
                    <button id="randomBtn">Randomize</button>
                </div>
                
                <h2 class="section-title" style="margin-top: 30px;">Export</h2>
                <div class="export-buttons">
                    <button class="export-btn" id="exportPNG">PNG</button>
                    <button class="export-btn" id="exportPixelArt">Pixel Art</button>
                    <button class="export-btn" id="exportJSON">JSON Data</button>
                </div>
                
                <div class="control-item" style="margin-top: 20px;">
                    <label for="worldName">World Name</label>
                    <input type="text" id="worldName" value="Generated_World" placeholder="Enter world name">
                </div>
            </div>
            
            <div class="world-display">
                <div class="world-header">
                    <h2>World Map</h2>
                    <div id="coordinates">Hover to inspect terrain</div>
                </div>
                <div class="world-canvas-container">
                    <canvas id="worldCanvas" width="1024" height="1024"></canvas>
                </div>
            </div>
        </div>
        
        <div class="stats-panel">
            <div class="stat-card">
                <div class="stat-value" id="landTiles">0</div>
                <div class="stat-label">Land Tiles</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="waterTiles">0</div>
                <div class="stat-label">Water Tiles</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="mountainTiles">0</div>
                <div class="stat-label">Mountains</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="beachTiles">0</div>
                <div class="stat-label">Beaches</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="forestTiles">0</div>
                <div class="stat-label">Forests</div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #1565C0;"></div>
                <span>Deep Water</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2196F3;"></div>
                <span>Shallow Water</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD54F;"></div>
                <span>Beach</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7CB342;"></div>
                <span>Plains</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2E7D32;"></div>
                <span>Forest</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #757575;"></div>
                <span>Mountains</span>
            </div>
        </div>
        
        <footer>
            Atlas World Generator
        </footer>
    </div>
    
    <div class="loading" id="loadingScreen">
        <div class="spinner"></div>
        <div class="loading-text">Generating World...</div>
        <div class="loading-details" id="loadingDetails">Initializing...</div>
    </div>
    
    <div class="notification" id="notification">World generated successfully!</div>

    <script>
        const canvas = document.getElementById('worldCanvas');
        const ctx = canvas.getContext('2d');
        const $ = id => document.getElementById(id);
        
        let worldSize = 256, landRatio = 0.45, complexity = 6;
        const enabledTerrains = new Set(['forests', 'mountains', 'beaches']);
        let worldData = [], heightMap = [], tempMap = [], moistMap = [];
        // Editor state
        let selectedTerrain = 4; // default to PLAINS
        let brushSize = 1;
        let isPainting = false;
        let currentMode = 'paint'; // 'paint' | 'erase' | 'eyedropper'
        
        const TERRAIN = {
            DEEP_WATER: 0, WATER: 1, SHALLOW: 2, BEACH: 3,
            PLAINS: 4, FOREST: 5, MOUNTAINS: 6,
            DESERT: 7, RAINFOREST: 8, TUNDRA: 9, GRASSLAND: 10
        };
        const COLORS = [
            '#0d47a1', // Deep Water
            '#1565c0', // Water
            '#1e88e5', // Shallow
            '#ffd54f', // Beach
            '#7cb342', // Plains
            '#2e7d32', // Forest
            '#757575', // Mountains
            '#e0c068', // Desert
            '#1b5e20', // Rainforest
            '#cfd8dc', // Tundra
            '#9ccc65'  // Grassland
        ];
        
        class Perlin {
            constructor(seed) {
                this.p = new Array(512);
                const p256 = Array.from({length: 256}, (_, i) => Math.floor(Math.sin(seed + i) * 10000) & 255);
                for (let i = 0; i < 512; i++) this.p[i] = p256[i & 255];
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(a, b, t) { return a + t * (b - a); }
            grad(h, x, y) {
                h &= 15;
                const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }
            perlin(x, y) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                x -= Math.floor(x); y -= Math.floor(y);
                const u = this.fade(x), v = this.fade(y);
                const a = this.p[X] + Y, b = this.p[X + 1] + Y;
                return this.lerp(
                    this.lerp(this.grad(this.p[this.p[a]], x, y), this.grad(this.p[this.p[b]], x - 1, y), u),
                    this.lerp(this.grad(this.p[this.p[a + 1]], x, y - 1), this.grad(this.p[this.p[b + 1]], x - 1, y - 1), u), v
                );
            }
        }
        
        function initArrays() {
            worldData = Array(worldSize).fill().map(() => Array(worldSize).fill(0));
            heightMap = Array(worldSize).fill().map(() => Array(worldSize).fill(0));
            tempMap = Array(worldSize).fill().map(() => Array(worldSize).fill(0));
            moistMap = Array(worldSize).fill().map(() => Array(worldSize).fill(0));
        }
        
        function normalizeHeightmap() {
            const flat = heightMap.flat().sort((a, b) => a - b);
            const thresh = flat[Math.floor(flat.length * (1 - landRatio))];
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    let h = heightMap[y][x];
                    heightMap[y][x] = Math.max(0, Math.min(1, h <= thresh ? (h / thresh) * 0.15 : 0.15 + ((h - thresh) / (1 - thresh)) * 0.85));
                }
            }
        }
        
        function heightToTerrain() {
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    const h = heightMap[y][x];
                    const t = tempMap[y][x];
                    const m = moistMap[y][x];
                    const r = Math.random();
                    // Water tiers
                    if (h < 0.06) worldData[y][x] = TERRAIN.DEEP_WATER;
                    else if (h < 0.10) worldData[y][x] = TERRAIN.WATER;
                    else if (h < 0.14) worldData[y][x] = TERRAIN.SHALLOW;
                    // Beach belt (low land near water)
                    else if (h < 0.18) worldData[y][x] = TERRAIN.BEACH;
                    else {
                        // High elevation -> mountains
                        if (h > 0.75) {
                            worldData[y][x] = enabledTerrains.has('mountains') ? TERRAIN.MOUNTAINS : TERRAIN.PLAINS;
                        } else {
                            // Biome selection by temp & moisture
                            if (m > 0.7 && t > 0.5) worldData[y][x] = TERRAIN.RAINFOREST;
                            else if (m < 0.25 && t > 0.55) worldData[y][x] = TERRAIN.DESERT;
                            else if (t < 0.25) worldData[y][x] = TERRAIN.TUNDRA;
                            else if (m > 0.55) worldData[y][x] = TERRAIN.FOREST;
                            else if (m > 0.3) worldData[y][x] = TERRAIN.GRASSLAND;
                            else worldData[y][x] = TERRAIN.PLAINS;
                        }
                    }
                }
            }
        }
        
        function genContinents() {
            const noise = new Perlin(Math.random() * 999999);
            const continents = Array.from({length: 3 + Math.floor(complexity / 3)}, () => ({
                x: Math.random() * worldSize, y: Math.random() * worldSize,
                size: 0.1 + Math.random() * 0.3, shape: Math.random() * 0.5 + 0.5
            }));
            
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    let val = 0;
                    continents.forEach(c => {
                        const dist = Math.sqrt(Math.pow((x - c.x) / worldSize, 2) + Math.pow((y - c.y) / worldSize, 2));
                        val += Math.pow(Math.max(0, 1 - dist / c.size), c.shape) * 0.8;
                    });
                    val += noise.perlin(x * 0.05, y * 0.05) * 0.3;
                    const lat = Math.abs((y / worldSize) - 0.5) * 2;
                    heightMap[y][x] = Math.min(1, Math.max(0, val + (1 - Math.pow(lat, 2)) * 0.3));
                }
            }
        }
        
        function genPerlin() {
            const noise = new Perlin(Math.random() * 999999);
            const scale = 0.05 + (complexity * 0.01), octaves = 3 + Math.floor(complexity / 3);
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    let val = 0, amp = 1, freq = 1, maxAmp = 0;
                    for (let o = 0; o < octaves; o++) {
                        val += noise.perlin(x * scale * freq, y * scale * freq) * amp;
                        maxAmp += amp; amp *= 0.5; freq *= 2;
                    }
                    heightMap[y][x] = (val / maxAmp + 1) / 2;
                }
            }
        }
        
        function genArchipelago() {
            const noise = new Perlin(Math.random() * 999999);
            for (let y = 0; y < worldSize; y++)
                for (let x = 0; x < worldSize; x++)
                    heightMap[y][x] = Math.random() * 0.2;
            
            for (let i = 0; i < 5 + Math.floor(complexity * 2); i++) {
                const cx = Math.floor(Math.random() * worldSize), cy = Math.floor(Math.random() * worldSize);
                const r = Math.floor(10 + Math.random() * 30);
                const maxH = 0.3 + Math.random() * 0.5;
                for (let y = Math.max(0, cy - r); y <= Math.min(worldSize - 1, cy + r); y++) {
                    for (let x = Math.max(0, cx - r); x <= Math.min(worldSize - 1, cx + r); x++) {
                        const d = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));
                        if (d < r) heightMap[y][x] = Math.max(heightMap[y][x], (1 - d / r) * maxH);
                    }
                }
            }
            for (let y = 0; y < worldSize; y++)
                for (let x = 0; x < worldSize; x++)
                    heightMap[y][x] += noise.perlin(x * 0.1, y * 0.1) * 0.2;
        }
        
        function genMountain() {
            const noise = new Perlin(Math.random() * 999999);
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    let val = 0, amp = 1, freq = 1, maxAmp = 0;
                    for (let o = 0; o < 4; o++) {
                        val += noise.perlin(x * 0.03 * freq, y * 0.03 * freq) * amp;
                        maxAmp += amp; amp *= 0.5; freq *= 2;
                    }
                    val = (val / maxAmp + 1) / 2;
                    const dist = Math.sqrt(Math.pow((x / worldSize - 0.5) * 2, 2) + Math.pow((y / worldSize - 0.5) * 2, 2));
                    heightMap[y][x] = val + (1 - dist) * 0.4;
                }
            }
        }

        function genClimate() {
            const noiseT = new Perlin(Math.random() * 999999);
            const noiseM = new Perlin(Math.random() * 999999);
            for (let y = 0; y < worldSize; y++) {
                const lat = Math.abs((y / worldSize) - 0.5) * 2; // 0 at equator, 1 at poles
                for (let x = 0; x < worldSize; x++) {
                    // temperature: basemap shaped by latitude + noise
                    let t = 1 - lat; // equator warm
                    t += noiseT.perlin(x * 0.02, y * 0.02) * 0.25;
                    // moisture: noise + coastal influence
                    let m = 0.5 + noiseM.perlin(x * 0.03, y * 0.03) * 0.4;
                    // coastal boost: check small neighborhood for water
                    let waterCount = 0, total = 0;
                    for (let dy = -3; dy <= 3; dy++) {
                        for (let dx = -3; dx <= 3; dx++) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < worldSize && ny >= 0 && ny < worldSize) {
                                total++;
                                if (heightMap[ny][nx] < 0.16) waterCount++;
                            }
                        }
                    }
                    const coastal = waterCount / (total || 1);
                    m = Math.max(0, Math.min(1, m + coastal * 0.45));
                    t = Math.max(0, Math.min(1, t));
                    moistMap[y][x] = m;
                    tempMap[y][x] = t;
                }
            }
        }
        
        function addBeaches() {
            if (!enabledTerrains.has('beaches')) return;
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    // Only convert plains to beaches (not forests or mountains)
                    if (worldData[y][x] === TERRAIN.PLAINS) {
                        let hasWater = false;
                        for (let dy = -1; dy <= 1 && !hasWater; dy++)
                            for (let dx = -1; dx <= 1 && !hasWater; dx++)
                                if (!(dx === 0 && dy === 0) && x + dx >= 0 && x + dx < worldSize && y + dy >= 0 && y + dy < worldSize)
                                    if (worldData[y + dy][x + dx] <= TERRAIN.SHALLOW) hasWater = true;
                        if (hasWater && Math.random() < 0.7) worldData[y][x] = TERRAIN.BEACH;
                    }
                }
            }
        }
        
        function applyToggles() {
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    const t = worldData[y][x];
                    // If forests are disabled, convert forests to plains
                    if (t === TERRAIN.FOREST && !enabledTerrains.has('forests')) {
                        worldData[y][x] = TERRAIN.PLAINS;
                    }
                    // If mountains are disabled, convert mountains to forests (if enabled) or plains
                    else if (t === TERRAIN.MOUNTAINS && !enabledTerrains.has('mountains')) {
                        worldData[y][x] = enabledTerrains.has('forests') ? TERRAIN.FOREST : TERRAIN.PLAINS;
                    }
                    // If beaches are disabled, convert beaches to plains
                    else if (t === TERRAIN.BEACH && !enabledTerrains.has('beaches')) {
                        worldData[y][x] = TERRAIN.PLAINS;
                    }
                }
            }
        }
        
        function generate() {
            initArrays();
            const type = $('generationType').value;
            if (type === 'continents') genContinents();
            else if (type === 'perlin') genPerlin();
            else if (type === 'archipelago') genArchipelago();
            else if (type === 'mountainous') genMountain();
            normalizeHeightmap();
            genClimate();
            heightToTerrain();
            addBeaches();
            applyToggles();
        }
        
        function render() {
            const cellSize = Math.max(1, Math.floor(1024 / worldSize));
            canvas.width = canvas.height = worldSize * cellSize;
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    ctx.fillStyle = COLORS[worldData[y][x]];
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        function updateStats() {
            let stats = {land:0, water:0, mountains:0, beach:0, forest:0};
            worldData.flat().forEach(t => {
                if (t <= TERRAIN.SHALLOW) stats.water++;
                else stats.land++;
                if (t === TERRAIN.MOUNTAINS) stats.mountains++;
                else if (t === TERRAIN.BEACH) stats.beach++;
                else if (t === TERRAIN.FOREST || t === TERRAIN.RAINFOREST) stats.forest++;
            });
            $('landTiles').textContent = stats.land.toLocaleString();
            $('waterTiles').textContent = stats.water.toLocaleString();
            $('mountainTiles').textContent = stats.mountains.toLocaleString();
            $('beachTiles').textContent = stats.beach.toLocaleString();
            $('forestTiles').textContent = stats.forest.toLocaleString();
        }
        
        function show(msg) {
            $('loadingScreen').style.display = 'flex';
            $('loadingDetails').textContent = msg;
        }
        
        function hide() {
            $('loadingScreen').style.opacity = '0';
            setTimeout(() => $('loadingScreen').style.display = 'none', 300);
        }
        
        function notify(msg) {
            $('notification').textContent = msg;
            $('notification').classList.add('show');
            setTimeout(() => $('notification').classList.remove('show'), 3000);
        }
        
        function init() {
            show('Generating...');
            setTimeout(() => {
                generate();
                render();
                updateStats();
                hide();
                notify('World generated!');
            }, 50);
        }
        
        $('worldSize').oninput = e => {
            worldSize = +e.target.value;
            $('sizeValue').textContent = `${worldSize} × ${worldSize}`;
        };
        
        $('landRatio').oninput = e => {
            landRatio = +e.target.value / 100;
            $('ratioValue').textContent = `${e.target.value}%`;
        };
        
        $('complexity').oninput = e => {
            complexity = +e.target.value;
            $('complexityValue').textContent = complexity.toFixed(1);
        };
        
        document.querySelectorAll('.terrain-toggle').forEach(t => {
            t.onclick = function() {
                const terrain = this.dataset.terrain;
                if (enabledTerrains.has(terrain)) {
                    enabledTerrains.delete(terrain);
                    this.classList.remove('active');
                } else {
                    enabledTerrains.add(terrain);
                    this.classList.add('active');
                }
            };
        });
        
        $('generateBtn').onclick = init;
        
        $('randomBtn').onclick = () => {
            worldSize = [128, 192, 256, 384, 512][Math.floor(Math.random() * 5)];
            $('worldSize').value = worldSize;
            $('sizeValue').textContent = `${worldSize} × ${worldSize}`;
            
            landRatio = (20 + Math.floor(Math.random() * 60)) / 100;
            $('landRatio').value = landRatio * 100;
            $('ratioValue').textContent = `${Math.floor(landRatio * 100)}%`;
            
            complexity = 3 + Math.random() * 7;
            $('complexity').value = complexity;
            $('complexityValue').textContent = complexity.toFixed(1);
            
            $('generationType').selectedIndex = Math.floor(Math.random() * 4);
            
            document.querySelectorAll('.terrain-toggle').forEach(t => {
                const terrain = t.dataset.terrain;
                if (Math.random() > 0.3) {
                    enabledTerrains.add(terrain);
                    t.classList.add('active');
                } else {
                    enabledTerrains.delete(terrain);
                    t.classList.remove('active');
                }
            });
            
            $('worldName').value = ['Fantasia', 'Terra Nova', 'Aetheria', 'Elysium', 'Arcadia'][Math.floor(Math.random() * 5)];
            init();
        };
        
        $('exportPNG').onclick = () => {
            notify('Exporting PNG...');
            const a = document.createElement('a');
            a.download = `${$('worldName').value || 'world'}.png`;
            a.href = canvas.toDataURL('image/png');
            a.click();
        };
        
        $('exportPixelArt').onclick = () => {
            notify('Exporting pixel art...');
            const pc = document.createElement('canvas'), ps = 8;
            pc.width = pc.height = worldSize * ps;
            const pctx = pc.getContext('2d');
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    pctx.fillStyle = COLORS[worldData[y][x]];
                    pctx.fillRect(x * ps, y * ps, ps, ps);
                }
            }
            const a = document.createElement('a');
            a.download = `${$('worldName').value || 'world'}_pixel.png`;
            a.href = pc.toDataURL('image/png');
            a.click();
        };
        
        $('exportJSON').onclick = () => {
            notify('Exporting JSON...');
            const data = {
                metadata: {
                    name: $('worldName').value || 'World',
                    size: worldSize,
                    landRatio, complexity,
                    type: $('generationType').value,
                    terrains: Array.from(enabledTerrains),
                    date: new Date().toISOString()
                },
                terrain: worldData,
                stats: {
                    land: $('landTiles').textContent,
                    water: $('waterTiles').textContent,
                    mountains: $('mountainTiles').textContent,
                    beaches: $('beachTiles').textContent,
                    forests: $('forestTiles').textContent
                }
            };
            const a = document.createElement('a');
            a.download = `${$('worldName').value || 'world'}.json`;
            a.href = 'data:application/json;charset=utf-8,'+ encodeURIComponent(JSON.stringify(data, null, 2));
            a.click();
        };
        
        // Palette wiring
        function updatePaletteUI() {
            document.querySelectorAll('.palette-btn').forEach(b => {
                if (+b.dataset.index === selectedTerrain) b.classList.add('active');
                else b.classList.remove('active');
            });
        }
        document.querySelectorAll('.palette-btn').forEach(b => {
            b.onclick = () => {
                selectedTerrain = +b.dataset.index;
                currentMode = 'paint';
                updatePaletteUI();
            };
        });
        $('brushSize').oninput = e => {
            brushSize = +e.target.value;
            $('brushValue').textContent = brushSize;
        };
        $('paintModeBtn').onclick = () => { currentMode = 'paint'; };
        $('eraseModeBtn').onclick = () => { currentMode = 'erase'; };
        $('eyedropperBtn').onclick = () => { currentMode = 'eyedropper'; };

        function getTileAtEvent(e) {
            const rect = canvas.getBoundingClientRect();
            const cellSize = canvas.width / worldSize;
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);
            return {x, y};
        }

        function applyBrushAt(tileX, tileY, terrain) {
            const r = brushSize;
            for (let dy = -r + 1; dy <= r - 1; dy++) {
                for (let dx = -r + 1; dx <= r - 1; dx++) {
                    const nx = tileX + dx, ny = tileY + dy;
                    if (nx >= 0 && nx < worldSize && ny >= 0 && ny < worldSize) {
                        worldData[ny][nx] = terrain;
                    }
                }
            }
        }

        canvas.addEventListener('mousedown', e => {
            if (e.button === 2) {
                // right-click pick
                const {x, y} = getTileAtEvent(e);
                if (x >= 0 && x < worldSize && y >= 0 && y < worldSize) {
                    selectedTerrain = worldData[y][x];
                    currentMode = 'paint';
                    updatePaletteUI();
                }
                return;
            }
            isPainting = true;
            const {x, y} = getTileAtEvent(e);
            if (x >= 0 && x < worldSize && y >= 0 && y < worldSize) {
                if (currentMode === 'eyedropper') {
                    selectedTerrain = worldData[y][x];
                    currentMode = 'paint';
                    updatePaletteUI();
                } else if (currentMode === 'erase') {
                    applyBrushAt(x, y, TERRAIN.PLAINS);
                } else {
                    applyBrushAt(x, y, selectedTerrain);
                }
                render(); updateStats();
            }
        });

        canvas.addEventListener('mousemove', e => {
            const {x, y} = getTileAtEvent(e);
            if (x >= 0 && x < worldSize && y >= 0 && y < worldSize) {
                const names = ['Deep Ocean','Ocean','Shallow Water','Beach','Plains','Forest','Mountains','Desert','Rainforest','Tundra','Grassland'];
                $('coordinates').textContent = `X: ${x}, Y: ${y} | ${names[worldData[y][x]]}`;
                if (isPainting && e.buttons & 1) {
                    if (currentMode === 'eyedropper') {
                        selectedTerrain = worldData[y][x];
                        currentMode = 'paint';
                        updatePaletteUI();
                    } else if (currentMode === 'erase') {
                        applyBrushAt(x, y, TERRAIN.PLAINS);
                    } else {
                        applyBrushAt(x, y, selectedTerrain);
                    }
                    render(); updateStats();
                }
            }
        });

        window.addEventListener('mouseup', () => { isPainting = false; });
        canvas.addEventListener('mouseleave', () => { isPainting = false; });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // initialize palette UI
        updatePaletteUI();
        
        window.onload = () => setTimeout(init, 100);
    </script>
</body>
</html>
